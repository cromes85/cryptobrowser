<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cours Crypto</title>
<style>
    body {
        background-color: white;
        color: black;
        font-family: Arial, sans-serif;
        text-align: center;
        padding-top: 50px;
        margin: 0;
    }
    h1 {
        font-size: 40px;
        margin-bottom: 20px;
    }
    .cryptoBlock {
        font-size: 70px;
        font-weight: bold;
        margin: 20px 0;
        line-height: 1.2em;
    }
    .previous {
        font-size: 20px;
        color: gray;
        margin-top: 5px;
        font-weight: normal;
    }
    #lastUpdate {
        margin-top: 30px;
        font-size: 20px;
        color: gray;
        display: block;
    }
    button {
        position: fixed;
        bottom: 10px;
        right: 10px;
        padding: 12px 20px;
        background-color: #ccc;
        border: none;
        cursor: pointer;
        border-radius: 5px;
        font-size: 16px;
    }
</style>
</head>
<body>
<h1>Cours Crypto</h1>
<div id="cryptoData">Chargement...</div>
<div id="lastUpdate">Dernière synchro : en attente...</div>
<button onclick="toggleMode()">Mode Bourse</button>

<script>
let useFallback = false;
let failCount = 0;
const maxFails = 10;

// Historique des valeurs précédentes
let previousPrices = { XRP: null, VELO: null, NANO: null };

function fetchCoinranking() {
    const apiUrl = "https://api.coinranking.com/v2/coins?symbols=XRP,VELO,NANO";
    const proxyUrl = "https://api.allorigins.win/get?url=" + encodeURIComponent(apiUrl);

    return fetch(proxyUrl)
        .then(res => res.json())
        .then(wrapper => {
            if (!wrapper || !wrapper.contents) throw new Error("Réponse vide Coinranking");
            const coins = JSON.parse(wrapper.contents).data.coins;
            const find = sym => coins.find(c => c.symbol === sym) || {};
            return {
                XRP: parseFloat(find("XRP").price).toFixed(6),
                VELO: parseFloat(find("VELO").price).toFixed(6),
                NANO: parseFloat(find("NANO").price).toFixed(6)
            };
        });
}

function fetchCoinGecko() {
    const apiUrl = "https://api.coingecko.com/api/v3/simple/price?ids=ripple,velodrome-finance,nano&vs_currencies=usd";
    const proxyUrl = "https://api.allorigins.win/get?url=" + encodeURIComponent(apiUrl);

    return fetch(proxyUrl)
        .then(res => res.json())
        .then(wrapper => {
            if (!wrapper || !wrapper.contents) throw new Error("Réponse vide CoinGecko");
            const data = JSON.parse(wrapper.contents);
            return {
                XRP: data.ripple?.usd ?? "N/A",
                VELO: data["velodrome-finance"]?.usd ?? "N/A",
                NANO: data.nano?.usd ?? "N/A"
            };
        });
}

function updateCryptoPrices() {
    (useFallback ? fetchCoinGecko() : fetchCoinranking())
    .then(prices => {
        let html = "";

        for (let key in prices) {
            html += `<div class="cryptoBlock">${key} : ${prices[key]} USD`;
            if (previousPrices[key] !== null) {
                html += `<div class="previous">Précédent : ${previousPrices[key]} USD</div>`;
            }
            html += `</div>`;

            // Mise à jour de l'historique
            previousPrices[key] = prices[key];
        }

        document.getElementById("cryptoData").innerHTML = html;
        document.getElementById("lastUpdate").innerText =
            "Dernière synchro : " + new Date().toLocaleDateString() + " " + new Date().toLocaleTimeString();

        if (useFallback && failCount === 0) {
            console.log("Retour à CoinRanking : service à nouveau fonctionnel.");
            useFallback = false;
        }
        failCount = 0;
    })
    .catch(err => {
        console.error("Erreur API:", err);
        failCount++;
        if (!useFallback && failCount >= maxFails) {
            console.warn("Coinranking échoue trop souvent, passage à CoinGecko.");
            useFallback = true;
        }
        document.getElementById("cryptoData").innerText = "Erreur de récupération des données";
    });
}

function toggleMode() {
    document.body.style.backgroundColor = 
        document.body.style.backgroundColor === "white" ? "black" : "white";
    document.body.style.color =
        document.body.style.color === "black" ? "white" : "black";
}

setInterval(updateCryptoPrices, 20000);
updateCryptoPrices();
</script>
</body>
</html>
