<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cours Crypto</title>
<style>
    body {
        background-color: white;
        color: black;
        font-family: Arial, sans-serif;
        text-align: center;
        padding-top: 50px;
    }
    #cryptoData {
        font-size: 70px;
        font-weight: bold;
        margin-top: 30px;
        line-height: 1.8em;
        display: inline-block;
        text-align: left;
    }
    #lastUpdate {
        margin-top: 20px;
        font-size: 18px;
        color: gray;
        display: block;
    }
    button {
        position: fixed;
        bottom: 10px;
        right: 10px;
        padding: 10px;
        background-color: #ccc;
        border: none;
        cursor: pointer;
        border-radius: 5px;
    }
</style>
</head>
<body>
<h1>Cours Crypto</h1>
<div id="cryptoData">Chargement...</div>
<div id="lastUpdate">Dernière synchro : en attente...</div>
<button onclick="toggleMode()">Mode Bourse</button>

<script>
let useFallback = false;
let failCount = 0;
const maxFails = 10;

function fetchCoinranking() {
    const apiUrl = "https://api.coinranking.com/v2/coins?symbols=XRP,VELO,NANO";
    const proxyUrl = "https://api.allorigins.win/get?url=" + encodeURIComponent(apiUrl);

    return fetch(proxyUrl)
        .then(res => res.json())
        .then(wrapper => {
            if (!wrapper || !wrapper.contents) throw new Error("Réponse vide Coinranking");
            const coins = JSON.parse(wrapper.contents).data.coins;
            const find = sym => coins.find(c => c.symbol === sym) || {};
            return {
                XRP: parseFloat(find("XRP").price).toFixed(6),
                VELO: parseFloat(find("VELO").price).toFixed(6),
                NANO: parseFloat(find("NANO").price).toFixed(6)
            };
        });
}

function fetchCoinGecko() {
    const apiUrl = "https://api.coingecko.com/api/v3/simple/price?ids=ripple,velodrome-finance,nano&vs_currencies=usd";
    const proxyUrl = "https://api.allorigins.win/get?url=" + encodeURIComponent(apiUrl);

    return fetch(proxyUrl)
        .then(res => res.json())
        .then(wrapper => {
            if (!wrapper || !wrapper.contents) throw new Error("Réponse vide CoinGecko");
            const data = JSON.parse(wrapper.contents);
            return {
                XRP: data.ripple?.usd ?? "N/A",
                VELO: data["velodrome-finance"]?.usd ?? "N/A",
                NANO: data.nano?.usd ?? "N/A"
            };
        });
}

function updateCryptoPrices() {
    (useFallback ? fetchCoinGecko() : fetchCoinranking())
    .then(prices => {
        document.getElementById("cryptoData").innerText =
            `XRP   : ${prices.XRP} USD\n` +
            `VELO  : ${prices.VELO} USD\n` +
            `NANO  : ${prices.NANO} USD`;
        document.getElementById("lastUpdate").innerText =
            "Dernière synchro : " + new Date().toLocaleDateString() + " " + new Date().toLocaleTimeString();
        failCount = 0; // reset compteur si succès
        if (useFallback) console.log("CoinGecko utilisé (fallback).");
    })
    .catch(err => {
        console.error("Erreur API:", err);
        failCount++;
        if (!useFallback && failCount >= maxFails) {
            console.warn("Coinranking échoue trop souvent, passage à CoinGecko.");
            useFallback = true;
        }
        document.getElementById("cryptoData").innerText = "Erreur de récupération des données";
    });
}

function toggleMode() {
    document.body.style.backgroundColor = 
        document.body.style.backgroundColor === "white" ? "black" : "white";
    document.body.style.color =
        document.body.style.color === "black" ? "white" : "black";
}

// Rafraîchissement toutes les 30 secondes
setInterval(updateCryptoPrices, 30000);
updateCryptoPrices();
</script>
</body>
</html>
